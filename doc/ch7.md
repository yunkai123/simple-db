# 第7部分-B树简介

B树是SQLite用来表示表和索引的数据结构，因此它是一个非常重要的概念。本文只介绍数据结构，没有任何代码。

为什么树是适用于数据库的良好数据结构？

- 搜索特定值很快（对数时间）
- 插入/删除已经找到的值很快（重新平衡树的时间固定）
- 遍历一个区间内的值很快（与哈希映射不同）

B树不同于二叉树（“B”可以代表发明人的名字，也可以代表“平衡”）。下面是一个B树示例：

![](/img/B-tree.png)

与二叉树不同，B树中的每个节点可以有两个子节点以上。每个节点最多可以有m个子节点，其中m称为树的“阶（order）”。为了保持树的大部分平衡，我们还要求节点必须至少有m/2个子节点（向上取整）。

例外情况：

- 叶节点有0个子节点
- 根节点的子节点可以少于m，但至少是2
- 如果根节点是叶节点（唯一节点），则它仍然有0个子节点

上图是一个B树，SQLite使用它来存储索引。为了存储表，SQLite使用了一种称为B+树的变体。

||B树|B+树|
|-|-|-|
|发音|“Bee Tree”|“Bee Plus Tree”|
|存储用途|索引|表|
|内部节点存储键|是|是|
|内部节点存储值|是|否|
|每个节点的子节点数|少|多|
|内部节点和叶子节点|相同结构|不同结构|

在实现索引之前，我将只讨论B+树，但我将把它称为B树。

具有子节点的节点称为“内部”节点。内部节点和叶节点的结构不同：

|对于有序m树|内部节点|叶子结点|
|-|-|-|
|存储|指向子节点的键和指针|键和值|
|键数量|m-1以下|尽可能多|
|指针数量|键数量+1|无|
|值数量|无|键数量|
|主要目的|用于路由|与值配对|
|存储值？|否|是|

让我们来看一个例子，看看在向B树中插入元素时，它是如何增长的。为了简单起见，树的阶为3。这意味着：


- 每个内部节点最多3个子节点
- 每个内部节点最多2个键
- 每个内部节点至少2个子节点
- 每个内部节点至少1个键

空B树只有一个节点：根节点。根节点从零个键/值对的叶子节点开始：

![](/img/btree1.png)

如果我们插入一对键/值对，它们将按排序顺序存储在叶子节点中：

![](/img/btree2.png)

假设叶子节点的容量是两个键/值对。当我们插入另一个节点时，我们必须拆分叶子节点，并在每个节点中放置一半。两个节点都成为新内部节点的子节点，这个内部节点现在将成为根节点。

![](/img/btree3.png)

内部节点有1个键和2个指向子节点的指针。如果我们想查找一个小于或等于5的键，我们可以查看左边的子节点。如果我们想查找大于5的键，我们会查找右边的子节点。

现在让我们插入键“2”。首先，如果它存在的话我们会在叶子节点中查找，然后我们到达左叶子节点。节点已满，因此我们拆分叶子节点并在父节点中创建一个新条目。

![](/img/btree4.png)

让我们继续添加键 18 和 21。我们必须再次拆分，但父节点中没有空间容纳另一个键/指针对。

![](/img/btree5.png)

解决方案是将根节点拆分为两个内部节点，然后创建新的根节点作为其父节点。

![](/img/btree6.png)

当我们拆分根节点时，树的深度才会增加。每个叶子节点都具有相同的深度和接近相同数量的键/值对，因此树保持平衡并可以快速搜索。

我将在实现插入之后再讨论从树中删除键。

当我们实现此数据结构时，每个节点将对应于一个页面。根节点将存在于页面0中。子指针将只是包含子节点的页码。

下一次，我们开始实现B树。

