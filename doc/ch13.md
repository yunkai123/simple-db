# 第13部分-拆分后更新父节点

在我们的史诗 B 树实现之旅的下一步中，我们将在拆分叶子节点后修复父节点。我将使用以下示例作为参考：

![](/img/updating-internal-node.png)

在本例中，我们将键“3”添加到树中。这会导致左叶子节点分裂。拆分后，我们通过执行以下操作修复树：

1. 将父节点中的第一个键更新为左子树（“3”）中的最大键
2. 在更新的键后添加新的子指针/键对
    - 新指针指向新的子节点
    - 新键是新子节点（“5”）中的最大键

因此，首先，用两个新函数调用替换我们的旧代码：第一步是 `update_internal_node_key()`，第二步是 `internal_node_insert()`。

为了获得对父节点的引用，我们需要在每个节点中记录一个指向其父节点的指针。

现在我们需要在父节点中找到受影响的单元。子节点不知道自己的页码，所以我们无法查找。但它知道自己的最大键，因此我们可以在父节点中搜索该键。

在 `internal_node_find_child()` 中，我们将重用我们已经拥有的一些代码来查找内部节点中的键。重构 `internal_node_find()` 以使用新的助手方法。

现在我们进入本文的核心，实现 `internal_node_insert()`。我会一步步详细解释。

应插入新单元格（子节点/键对）的索引取决于新子节点的最大键。在我们看到的示例中，`child_max_key` 将为5，`index`将为1。

如果内部节点中没有其他单元格的空间，则抛出错误。我们稍后会实现它。

现在让我们看看函数的其余部分：

因为我们将最右边的子指针与其他子节点/键对分开存储，如果新的子节点将成为最右边的子节点，我们必须以不同的方式处理。

在我们的示例中，我们将进入 `else` 代码块。首先，我们通过将其他单元格向右移动一个空间来为新单元格腾出空间。（尽管在我们的示例中，有0个单元格要移动）

接下来，我们将新的子指针和键写入由索引确定的单元格中。

为了减少所需测试用例的大小，我现在对 `INTERNAL_NODE_MAX_CELLS` 进行硬编码

说到测试，我们的大型数据集测试将越过旧代码，进入新代码：

我将添加另一个打印四节点树的测试。由于我们大部分的测试案例都是顺序ID，这个测试将以伪随机顺序添加记录。


仔细看，你会发现一个错误：

键应该是7，而不是1！

经过大量调试，我发现这是由于一些糟糕的指针运算。

`INTERNAL_NODE_CHILD_SIZE` 是4。我的意图是在 `internal_node_cell()` 的结果中添加4个字节，但由于 `internal_node_cell()` 返回一个 `uint32_t*`，这实际上是添加了`4*sizeof(uint32-t)`字节。在做算术之前，我通过一个 `void*` 类型转换进行了修正。

注意！无效指针上的指针算术不是C标准的一部分，可能不适用于编译器。我可能会在未来写一篇关于可移植性的文章，但我现在就离开我的空指针算法。

好吧向全面运行的B树实现又迈进了一步。下一步应该是拆分内部节点。