# 第6部分——游标抽象层

本部分比上一部分短很多。我们只需要进行一些重构，以使B树实现更容易。

我们将添加一个 `Cursor` 对象，它表示表中的一个位置。你可能希望使用游标执行如下操作：

- 在表的开头创建游标
- 在表地末尾创建游标
- 访问游标指向的行
- 将游标移到下一行

这些就是我们要实现地行为，后续我们还需要：

- 删除游标指向的行
- 修改游标指向的行
- 在表中搜索给定ID，并创建一个指向具有该ID的行的游标

先不考虑后续，下面是 `Cursor` 类型：

考虑到我们当前的表数据结构，你只需要识别表中行号的位置。


游标还具有对其所属表的引用（因此我们的游标函数可以仅将游标作为参数）。

最后，它有一个名为 `end_of_table` 的布尔值。这样我们就可以表示超过表末尾的位置（这是我们可能要插入一行的地方）。

`table_start()` 和 `table_end()` 创建新的游标：

我们的 `row_slot()` 函数将成为 `cursor_value()`，它返回一个指针，指向光标所描述的位置：

在我们当前的表结构中推进光标就像增加行号一样简单。在B树中，这会更加复杂。

最后，我们可以将“虚拟机”方法更改为使用游标抽象层。插入行时，我们在表的末尾打开一个游标，写入该游标位置，然后关闭游标。

当选择表中的所有行时，我们在表的开头打开一个游标，打印该行，然后将游标前进到下一行。重复上述操作，直到我们到达表末尾。


好了，就这样！正如我所说，这是一个较短的重构，当我们将表数据结构重写为B树时，它会帮助我们。`execute_select()` 和 `execute_insert()` 可以完全通过游标与表交互，而不需要假设任何关于表存储方式的信息。


